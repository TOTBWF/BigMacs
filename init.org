#+TITLE: BigMacs
#+AUTHOR: Reed Mullanix
#+TOC: true

This is my emacs config, inspired by [[https://github.com/jamiecollinson/dotfiles/blob/master/config.org/][Jamie Collinsons]].

* Setup
** Package Management
    First, let's load up some basic bootstrap code for [[https://github.com/raxod502/straight.el][straight.el.]]
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defvar bootstrap-version)
	(let ((bootstrap-file
	    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	    (bootstrap-version 5))
	(unless (file-exists-p bootstrap-file)
	    (with-current-buffer
		(url-retrieve-synchronously
		"https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
		'silent 'inhibit-cookies)
  	    (goto-char (point-max))
	    (eval-print-last-sexp)))
	(load bootstrap-file nil 'nomessage))
    #+END_SRC

    Now, let's load up [[https://github.com/jwiegley/use-package][use-package]].
    #+BEGIN_SRC emacs-lisp :tangle yes
    (straight-use-package 'use-package)
    #+END_SRC
** Benchmark Setup
   [[https://github.com/dholm/benchmark-init-el][benchmark-init]] records startup time by package so we can debug. 
   It only records things after it's initialised, so put as early in config as possible.
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package benchmark-init
     :straight t
     :config
     ;; Disable collection of benchmark data after init is done
     (add-hook 'after-init-hook 'benchmark-init/deactivate))

   (add-hook 'after-init-hook
	     (lambda () (message "loaded in %s" (emacs-init-time))))
   #+END_SRC
** Avoid GC during initialization.
   By default, the GC threshold for emacs is 800kb, so let's bump this up to 
   10MB to avoid GC when initializing.
   #+BEGIN_SRC emacs-lisp :tangle yes
   (setq gc-cons-threshold 10000000)

   ;; Restore after startup
   (add-hook 'after-init-hook
             (lambda ()
               (setq gc-cons-threshold 1000000)
               (message "gc-cons-threshold restored to %S"
                        gc-cons-threshold)))
   #+END_SRC
* Preferences
  Don't show the help screen on startup.
  #+BEGIN_SRC emacs-lisp :tangle yes
  (setq inhibit-startup-screen t)
  #+END_SRC

  Let's disable some un-needed window decorations.
  #+BEGIN_SRC emacs-lisp :tangle yes
  (tool-bar-mode -1)
  (scroll-bar-mode -1) 
  #+END_SRC

  The error bell is really obnoxious, so let's just turn it off.
  #+BEGIN_SRC emacs-lisp :tangle yes
  (setq ring-bell-function 'ignore)
  #+END_SRC
  
  Don't fill the filesystem with garbage please.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
	  backup-by-copying t
	  backup-directory-alist '((".*" . "~/.emacs-tmp"))
	  delete-old-versions t
	  kept-new-versions 6
	  kept-old-versions 2
	  version-control t)
  #+END_SRC
  
  Never, ever use tabs.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq indent-tabs-mode nil)
  #+END_SRC
  
  Make 'yes or no' prompts shorter.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defalias 'yes-or-no-p 'y-or-n-p)
  #+END_SRC

  
  For whatever reason, adding things to ~exec-path~ can be a bit wonky, so let's define
  a helper for doing just that.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun add-to-path (path)
      (add-to-list 'exec-path path)
      (setenv "PATH" (concat path ":" (getenv "PATH"))))
  #+END_SRC

  A lot of our commands live inside of ~/usr/local/bin~, so let's load it up!
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-path "/usr/local/bin/")
  #+END_SRC
  
  Make sure to follow symlinks
  #+BEGIN_SRC emacs-lisp :tangle yes
      (setq vc-follow-symlinks t)
  #+END_SRC
  
  Highlight matching parens
  #+BEGIN_SRC emacs-lisp :tangle yes
    (show-paren-mode)
  #+END_SRC
  
  Highlight between point and selection start.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (transient-mark-mode)
  #+END_SRC
  
  Fix scrolling
  #+BEGIN_SRC emacs-lisp :tangle yes
  (setq scroll-conservatively 101
        mouse-wheel-scroll-amount '(1)
        mouse-wheel-progressive-speed nil)
  #+END_SRC
* Themes
  There are a few options here, as I haven't totally settled.
* Interface
** Evil
  [[https://github.com/emacs-evil/evil][evil]] provides us with vim-like keybindings inside of emacs.
  #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package evil
    :init
    (setq evil-want-C-u-scroll t)
    :straight t)
  (evil-mode 1)
  (define-key evil-motion-state-map " " nil)
  (define-key evil-motion-state-map (kbd ";") 'evil-ex)
  #+END_SRC

  Next, let's install [[https://github.com/linktohack/evil-commentary][evil-commentary]], which lets us easily comment out code. 
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil-commentary
      :straight t
      :config
      (evil-commentary-mode))
  #+END_SRC
** Ivy
  For our filtering needs, we are going to use ivy.
  To start, let's load up all of the ivy packages.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy
      :straight t
      :init
      (setq ivy-re-builders-alist
	    '((counsel-rg . ivy--regex-plus)
	      (swiper . ivy--regex-plus)
	      (t . ivy--regex-ignore-order)))
      :config
      (ivy-mode 1)
      :bind (:map evil-motion-state-map
		  ("/" . 'swiper)))

    (use-package hydra
      :straight t)

    (use-package counsel
      :straight t
      :config
      (counsel-mode 1)
      :bind (:map evil-motion-state-map
	     ("SPC ." . 'counsel-find-file)
	     :map global-map
	     ("M-x" . 'counsel-M-x)))

    (use-package ivy-hydra
      :straight t
      :after (ivy hydra))
  #+END_SRC
  
  By default =ivy= starts every regex with ~^~. I find this annoying,
  so let's just set it to an empty string.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq ivy-initial-inputs-alist nil)
  #+END_SRC
** Which Key
  Next, let's add [[https://github.com/justbur/emacs-which-key][which-key]].
  #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :straight t)
  (which-key-mode)
  #+END_SRC

  To enable custom prefix names, we need to set =which-key-enable-extended-define-key=.
  #+BEGIN_SRC emacs-lisp :tangle yes
  (setq which-key-enable-extended-define-key t)
  #+END_SRC
  
  Finally, lets enable =which-key-mode=.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (which-key-mode 1)
  #+END_SRC
** Modeline
** Help
  First, let's bind some of the =describe= functions
  to keys that are more in line with vim.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (evil-define-key 'normal 'global
      (kbd "SPC h k") 'describe-key
      (kbd "SPC h f") 'counsel-describe-function
      (kbd "SPC h v") 'counsel-describe-variable
      (kbd "SPC h F") 'counsel-describe-face
      (kbd "SPC h m") 'describe-mode
      (kbd "SPC h i") 'info)

    (which-key-add-key-based-replacements
      "SPC h" "help"
      "SPC h k" "describe key"
      "SPC h f" "describe function"
      "SPC h F" "describe face"
      "SPC h v" "describe variable"
      "SPC h m" "describe mode"
      "SPC h i" "info")
  #+END_SRC
** Buffers
  Let's bind buffer management to some nicer keys.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (evil-define-key 'normal 'global
      (kbd "SPC ,") 'ivy-switch-buffer
      (kbd "SPC b b") 'ivy-switch-buffer
      (kbd "SPC b k") 'kill-current-buffer)
  #+END_SRC
  Next, let's make =which-key= display our key bindings in a nice way.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (which-key-add-key-based-replacements
      "SPC ," "switch buffer"
      "SPC b" "buffer"
      "SPC b b" "switch buffer"
      "SPC bk" "kill")
  #+END_SRC
** Files
  Some handy bindings for opening files
  #+BEGIN_SRC emacs-lisp :tangle yes
    (evil-define-key 'normal 'global
      (kbd "SPC f f") 'counsel-find-file
      (kbd "SPC .") 'counsel-find-file
      (kbd "SPC f r") 'counsel-recentf
      (kbd "SPC f i") (lambda () (interactive) (find-file "~/.emacs.d/init.org")))

    (which-key-add-key-based-replacements
      "SPC f" "files"
      "SPC f f" "find file"
      "SPC f r" "recent files"
      "SPC f i" "config file"
      "SPC ." "find file")
  #+END_SRC
** Windows
  Let's bind window management to some nicer keys
  #+BEGIN_SRC emacs-lisp :tangle yes
    (evil-global-set-key 'normal (kbd "SPC w h") 'evil-window-left)
    (evil-global-set-key 'normal (kbd "SPC w k") 'evil-window-up)
    (evil-global-set-key 'normal (kbd "SPC w j") 'evil-window-down)
    (evil-global-set-key 'normal (kbd "SPC w l") 'evil-window-right)

    (evil-global-set-key 'normal (kbd "SPC w v") 'evil-window-vsplit)
    (evil-global-set-key 'normal (kbd "SPC w s") 'evil-window-split)
    (evil-global-set-key 'normal (kbd "SPC w q") 'evil-window-delete)
  #+END_SRC

  Next, let's make =which-key= display our key bindings in a nice way.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (which-key-add-key-based-replacements
      "SPC w" "window"
      "SPC wh" "left"
      "SPC wk" "up"
      "SPC wj" "down"
      "SPC wl" "right"
      "SPC wv" "vertical split"
      "SPC ws" "horizontal split"
      "SPC wq" "close"
      )
  #+END_SRC
** Tabs
   Let's use emacs 27 recently added tab support to emulate workspaces.
   
   First, let's define a nice ivy interface for selecting which tab to switch to.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun counsel-switch-tab ()
       "Switch to another tab."
       (interactive)
       (ivy-read "Tab: " '("Schema.fs" "*ielm*")
		 ;; (mapcar (lambda (tab) (cdr (assq 'name tab))) (tab-bar-tabs))
		 :caller 'counsel-switch-tab))


   #+END_SRC


   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key 'normal 'global
       (kbd "SPC t l") 'tab-next
       (kbd "SPC t h") 'tab-previous
       (kbd "SPC t k") 'tab-close
       (kbd "SPC t n") 'tab-new
       (kbd "SPC t r") 'tab-bar-rename-tab
       (kbd "SPC t b") 'switch-to-buffer-other-tab
       (kbd "g t") 'tab-next
       (kbd "g T") 'tab-previous)

     (which-key-add-key-based-replacements
       "SPC t" "tabs"
       "SPC t n" "new tab"
       "SPC t r" "rename tab"
       "SPC t k" "delete tab"
       "SPC t h" "previous tab"
       "SPC t l" "next tab"
       "SPC t b" "open buffer in tab"
       "g t" "next tab"
       "g T" "previous tab")
   #+END_SRC

   #+RESULTS:

* Org
** Keybindings
   =org-mode= is a monster of a mode, with approximately 50 million keybindings.
   As such, this is very much a work in progress!
** Babel
   It's a bit annoying that =org-babel= asks for confirmation all the time,
   so let's turn it off.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC
** Jira
   Let's enable [[https://github.com/ahungry/org-jira][org-jira]].
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package org-jira
       :straight t
       :config
       (setq jiralib-url "https://bazinga.atlassian.net")
       (setq org-jira-use-status-as-todo t)
       (add-to-list 'org-todo-keywords '(sequence
					 "BACKLOG(b)"
					 "SELECTED-FOR-DEVELOPMENT(s)"
					 "IN-PROGRESS(i)"
					 "IN-REVIEW(r)"
					 "READY-FOR-QA(q)"
					 "|"
					 "DONE(d)"
					 "REMOVED(R)")))
   #+END_SRC
   
   Next, let's add some nice keybindings
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key 'normal 'global
       (kbd "SPC f j") (lambda () (interactive) (find-file org-jira-working-dir)))

     (which-key-add-key-based-replacements
       "SPC f j" "jira file")
   #+END_SRC
* Editor
** Projectile
  [[https://github.com/bbatsov/projectile][projectile]] is a project system for emacs, which lets find navigate
  our projects much faster.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package projectile
      :straight t)
  #+END_SRC
  
  To integrate =projectile= into our =ivy= based workflow, we are going to use
  [[https://github.com/ericdanan/counsel-projectile][counsel-projectile]].
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel-projectile
      :straight t)
  #+END_SRC
  
  Finally, let's enable =projectile-mode= globally, and bind the keymap.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (evil-define-key 'normal projectile-mode-map (kbd "SPC p") 'projectile-command-map)
    (projectile-mode 1)
    (counsel-projectile-mode 1)
  #+END_SRC
  
  Finally, let's add some nice =which-key= support
  #+BEGIN_SRC emacs-lisp :tangle yes
    (evil-define-key 'normal 'global
      (kbd "SPC SPC") 'counsel-projectile-find-file)
    (which-key-add-key-based-replacements
      "SPC SPC" "find project file"
      "SPC p" "project")
  #+END_SRC
** Autocompletion
  For autocompletion, we are going to use [[https://github.com/company-mode/company-mode][company-mode]].
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package company
      :straight t
      :config
      (setq company-tooltip-align-annotations t
	    company-idle-delay 0.3
	    company-echo-delay 0))
  #+END_SRC
  
  For now, let's enable it globally.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (global-company-mode)
  #+END_SRC

  Start autocompletion when you press tab.
  #+BEGIN_SRC emacs-lisp :tangle yes
  (define-key company-mode-map (kbd "TAB") #'company-indent-or-complete-common)
  #+END_SRC
** Snippets
   We use [[https://github.com/joaotavora/yasnippet][yasnippet]] for all of our snippeting needs.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package yasnippet
       :straight t)
   #+END_SRC
   
   The default yas bindings are pretty hard to use, so let's rebind them.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key 'normal 'global
       (kbd "SPC s n") 'yas-new-snippet
       (kbd "SPC s i") 'yas-insert-snippet
       (kbd "SPC s e") 'yas-visit-snippet-file)
   #+END_SRC
   
   As per usual, let's use =which-key= to give these nicer names.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (which-key-add-key-based-replacements
       "SPC s" "snippets"
       "SPC s n" "new snippet"
       "SPC s i" "insert snippet"
       "SPC s e" "edit snippet")
   #+END_SRC

   Lets enable =yasnippet= globally.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (yas-global-mode 1)
   #+END_SRC
** Flymake
   We use =flymake= to handle displaying errors inside of buffers.
   However, there a few tweaks required to get things working nicely OOTB.
   
   For starters, =flymake= doesn't show errors in a posframe, so we need to install
   [[https://github.com/Ladicle/flymake-posframe][flymake-posframe]] for that.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flymake-posframe
       :straight (flymake-posframe :type git :host github
				   :repo "Ladicle/flymake-posframe")
       :hook (flymake-mode . flymake-posframe-mode))
   #+END_SRC
   
   Next, let's add some nice keybindings.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key 'normal 'global
       (kbd "SPC e j") 'flymake-goto-next-error
       (kbd "SPC e k") 'flymake-goto-prev-error
       (kbd "SPC e e") 'flymake-show-diagnostics-buffer)

     (which-key-add-key-based-replacements
       "SPC e" "errors"
       "SPC e j" "next error"
       "SPC e k" "previous error"
       "SPC e e" "display errors")
   #+END_SRC
   
   Now, the =flymake= diagnostic buffer will pop up somewhat randomly, so let's make sure it only
   ever pops up at the bottom.
   
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'display-buffer-alist
		  '("\\*Flymake diagnostics*"
		    (display-buffer-below-selected display-buffer-at-bottom)
		    (inhibit-same-window . t)
		    (window-height . 15)))
   #+END_SRC

** SmartParens
   [[https://github.com/Fuco1/smartparens][smartparens]] provides a bunch of utilities for handling
   pairs in emacs.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package smartparens
       :straight t)
   #+END_SRC
   
   By default, we turn on smartparens globally (but not strict mode).
   The default config is pretty good, so let's bring that in as well.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'smartparens-config)
     (smartparens-global-mode)
   #+END_SRC
   
   In other modes (namely lisps) we will want strict mode, so let's also add
   [[https://github.com/expez/evil-smartparens][evil-smartparens]].
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-smartparens
       :straight t)
   #+END_SRC
   
   However, some of the features are still handy, so let's add it as a hook
   to =prog-mode=.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'prog-mode-hook 'evil-smartparens-mode)
   #+END_SRC

   Here are some helpful keybinds.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key 'normal 'global
       "((" 'sp-wrap-round
       "([" 'sp-wrap-square
       "({" 'sp-wrap-curly)
   #+END_SRC

** Rainbow Parens
   Turn on [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]].
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package rainbow-delimiters
       :straight t
       :config
       (rainbow-delimiters-mode))
   #+END_SRC
* LSP
  [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] provides language services for quite a few languages.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package lsp-mode
      :straight t
      :commands lsp)
  #+END_SRC

  Next, let's add [[https://github.com/tigersoldier/company-lsp][company-lsp]] for autocompletion support.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package company-lsp
      :straight t
      :commands company-lsp)
  #+END_SRC
  
  Once that's installed, we have to register it as a company backend.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'company-lsp)
    (push 'company-lsp company-backend)
  #+END_SRC

  Next, it's a bit of a pain having to manually set + unset ~lsp-log-io~, so
  let's write a little helper.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun lsp-toggle-log-io ()
	"Toggle `lsp-log-io'"
	(interactive)
	(if lsp-log-io
	    (setq lsp-log-io nil)
	  (setq lsp-log-io t))
	(if lsp-print-performance
	    (setq lsp-print-performance t)
	  (setq lsp-print-performance nil)))
  #+END_SRC

  #+RESULTS:
  : lsp-toggle-log-io

* Tools
** Magit
   To start, let's install [[https://github.com/magit/magit][magit]].
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package magit
       :straight t
       :bind (:map evil-motion-state-map
		   ("SPC g g" . 'magit-status)))
   #+END_SRC
   
   =magit= is a fantastic tool, but the keybindings don't quite line up with =evil=.
   Let's change that by using [[https://github.com/emacs-evil/evil-magit][evil-magit]].
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-magit
       :straight t)
   #+END_SRC
   
   Finally, let's give our prefix a nice name!
   #+BEGIN_SRC emacs-lisp :tangle yes
     (which-key-add-key-based-replacements
       "SPC g" "git"
       "SPC g g" "status")
   #+END_SRC
** Brew
   It's a pain having to switch to the terminal to use brew,
   so let's use [[https://github.com/TOTBWF/counsel-brew][counsel-brew]] instead.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel-brew
       :straight (counsel-brew :type git :host github
			       :repo "TOTBWF/counsel-brew")
       :commands counsel-brew)
   #+END_SRC
** Docker
   I use =counsel-docker= to manage docker containers.
   As of right now, this is a WIP, so let's just bring this in from source.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel-docker
       :load-path "~/Documents/projects/counsel-docker")
   #+END_SRC
   
   Next up, let's bind some keys.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key 'normal 'global
       (kbd "SPC d i") 'counsel-docker-image
       (kbd "SPC d c") 'counsel-docker-container)

     (which-key-add-key-based-replacements
       "SPC d" "docker"
       "SPC d i" "images"
       "SPC d c" "containers")
   #+END_SRC

** GraphiQL
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package graphiql
       :load-path "~/Documents/projects/graphiql.el"
       :config
       (setq graphiql-use-lsp t))
   #+END_SRC

   #+RESULTS:
   : t

** GPG
   Enable prompting for GPG pins.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq epa-pinentry-mode 'loopback)
   #+END_SRC

* Languages
  This section covers language specific configuration.
** Agda
   First, we need to load the =agda-input= package.
   This provides an input method for writing agda code.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package agda-input
       :straight (agda-input :type git :host github :repo "agda/agda"
			     :files ("src/data/emacs-mode/agda-input.el")))
   #+END_SRC
   
   Now, let's load up =agda2-mode= itself.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package agda2-mode
       :straight (agda2-mode :type git :host github 
			     :repo "agda/agda"
			     :files ("src/data/emacs-mode/*.el"
				     (:exclude "agda-input.el")))
       :config
       (add-to-list 'exec-path "~/.local/bin/"))
   #+END_SRC

** CSS
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'less-css-mode-hook #'lsp)
     (add-hook 'css-mode-hook #'lsp)
     (setq css-indent-offset 2)
   #+END_SRC
** Emacs Lisp
   Let's enable =flymake-mode= when editing elisp code.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package lispy
       :straight t)
     (add-hook 'emacs-lisp-mode-hook 'flymake-mode)
     (add-hook 'emacs-lisp-mode-hook 'lispy-mode)
   #+END_SRC
** F#
   We use [[https://github.com/fsharp/emacs-fsharp-mode][fsharp-mode]] to provide font locking and indentation for F#.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package fsharp-mode
       :straight t
       :config
       (add-hook 'fsharp-mode-hook 'lsp)
       :custom
       (fsharp-ac-intellisense-enabled nil))
   #+END_SRC
   
   Next, let's load up the F# language server from =lsp-mode=
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'lsp-fsharp)
   #+END_SRC
   
   Finally, let's make sure that the =dotnet= executable is available on our path.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-path "/usr/local/share/dotnet/")
   #+END_SRC
** Typescript
   Typescript is a bit of a pain to get working, mostly due to
   the evils of JSX.
   
   We are going to need to install [[http://web-mode.org/][web-mode]] for =tsx= support.
   Emacs 27 did add =jsx= support, but the indentation behaves rather oddly
   when dealing with type annotations.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package web-mode
       :straight t
       :custom
       (web-mode-code-indent-offset 2 "Set indentation of js code to 2")
       (web-mode-markup-indent-offset 2 "Set indentation of js code to 2"))
   #+END_SRC
   
   Next, let's load the typescript language server.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
     (add-hook 'web-mode-hook
	       (lambda ()
		 (when (string= web-mode-content-type "jsx")
		   (lsp))))
   #+END_SRC

