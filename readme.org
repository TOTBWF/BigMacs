#+TITLE: BigMacs
#+AUTHOR: Reed Mullanix
#+PROPERTY: header-args :tangle yes :results silent
#+TOC: true

This is my emacs config, inspired by [[https://github.com/jamiecollinson/dotfiles/blob/master/config.org/][Jamie Collinsons]].
There is also some extra info at [[https://github.com/noctuid/evil-guide][evil-guide]] that is quite helpful.

* Setup
** Package Management
   First, let's load up some basic bootstrap code for [[https://github.com/raxod502/straight.el][straight.el.]]
   #+BEGIN_SRC emacs-lisp
     (defvar bootstrap-version)
     (let ((bootstrap-file
            (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))
   #+END_SRC

   Now, let's load up [[https://github.com/jwiegley/use-package][use-package]].
   #+BEGIN_SRC emacs-lisp
     (straight-use-package 'use-package)
   #+END_SRC
** Benchmark Setup
   [[https://github.com/dholm/benchmark-init-el][benchmark-init]] records startup time by package so we can debug.
   It only records things after it's initialised, so put as early in config as possible.
   #+BEGIN_SRC emacs-lisp
     (use-package benchmark-init
       :straight t
       :config
       ;; Disable collection of benchmark data after init is done
       (add-hook 'after-init-hook 'benchmark-init/deactivate))

     (add-hook 'after-init-hook
               (lambda () (message "loaded in %s" (emacs-init-time))))
   #+END_SRC
** Restarting Emacs
   Let's install [[https://github.com/iqbalansari/restart-emacs/tree/9aa90d3df9e08bc420e1c9845ee3ff568e911bd9][restart-emacs]].
   #+BEGIN_SRC emacs-lisp
     (use-package restart-emacs
       :straight t
       :commands (restart-emacs))
   #+END_SRC

** Avoid GC during initialization.
   By default, the GC threshold for emacs is 800kb, so let's bump this up to
   10MB to avoid GC when initializing.
   #+BEGIN_SRC emacs-lisp
     (setq gc-cons-threshold 10000000)

     ;; Restore after startup
     (add-hook 'after-init-hook
               (lambda ()
                 (setq gc-cons-threshold 1000000)
                 (message "gc-cons-threshold restored to %S"
                          gc-cons-threshold)))
   #+END_SRC
** Figuring out errors
   Let's install [[https://github.com/Malabarba/elisp-bug-hunter][bug-hunter]] so that we
   can bisect our config and track down annoying
   behavior.
   #+BEGIN_SRC emacs-lisp
     (use-package bug-hunter
       :straight t)
   #+END_SRC

** Binding Keys
   Let's use [[https://github.com/noctuid/general.el][general.el]] to bind our keys in a more consistent way.
   #+BEGIN_SRC emacs-lisp  :results silent
     (use-package general
       :straight t
       :config
       (general-evil-setup)
       (general-auto-unbind-keys))
   #+END_SRC
* Preferences
  Don't show the help screen on startup.
  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-screen t)
  #+END_SRC

  Let's disable some un-needed window decorations.
  #+BEGIN_SRC emacs-lisp
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (menu-bar-mode -1)
  #+END_SRC

  The error bell is really obnoxious, so let's just turn it off.
  #+BEGIN_SRC emacs-lisp
    (setq ring-bell-function 'ignore)
  #+END_SRC

  Don't fill the filesystem with garbage please.
  #+BEGIN_SRC emacs-lisp
    (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
          backup-by-copying t
          backup-directory-alist '((".*" . "~/.emacs-tmp"))
          delete-old-versions t
          kept-new-versions 6
          kept-old-versions 2
          version-control t)
  #+END_SRC

  Never, ever use tabs.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'prog-mode-hook (lambda ()
                                (setq indent-tabs-mode nil)))
  #+END_SRC

  Make 'yes or no' prompts shorter.
  #+BEGIN_SRC emacs-lisp
    (defalias 'yes-or-no-p 'y-or-n-p)
  #+END_SRC


  For whatever reason, adding things to ~exec-path~ can be a bit wonky, so let's define
  a helper for doing just that.
  #+BEGIN_SRC emacs-lisp
    (defun add-to-path (path)
      (add-to-list 'exec-path path)
      (setenv "PATH" (concat path ":" (getenv "PATH"))))
  #+END_SRC

  A lot of our commands live inside of ~/usr/local/bin~, so let's load it up!
  #+BEGIN_SRC emacs-lisp
    (add-to-path "/usr/local/bin/")
  #+END_SRC

  Make sure to follow symlinks
  #+BEGIN_SRC emacs-lisp
    (setq vc-follow-symlinks t)
  #+END_SRC

  Highlight matching parens
  #+BEGIN_SRC emacs-lisp
    (show-paren-mode)
  #+END_SRC

  Highlight between point and selection start.
  #+BEGIN_SRC emacs-lisp
    (transient-mark-mode)
  #+END_SRC

  Fix scrolling
  #+BEGIN_SRC emacs-lisp
    (setq scroll-conservatively 101
          mouse-wheel-scroll-amount '(1)
          mouse-wheel-progressive-speed nil)
  #+END_SRC

  Avoid calling =line-move-partial=, increasing scroll speed.
  See [[https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746][this]] for a more in-depth explanation.
  #+BEGIN_SRC emacs-lisp
    (setq auto-window-vscroll nil)
  #+END_SRC

* Themes
  There are a few options here, as I haven't totally settled.
  #+BEGIN_SRC emacs-lisp
    (use-package doom-themes
      :straight t
      :config
      (load-theme 'doom-one t))
  #+END_SRC
* Interface
** Modeline
   Let's add =diminish= so that we can easily theme the modeline.
   #+BEGIN_SRC emacs-lisp
     (use-package diminish
       :straight t)
   #+END_SRC

   Next, let's add some helpful indicators.
   #+BEGIN_SRC emacs-lisp
     (display-time-mode 1)
     (display-battery-mode 1)
     (column-number-mode 1)
   #+END_SRC
** Which Key
   First, let's add [[https://github.com/justbur/emacs-which-key][which-key]].
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :diminish which-key-mode
       :straight t)
     (which-key-mode)
   #+END_SRC

   To enable custom prefix names, we need to set =which-key-enable-extended-define-key=.
   #+BEGIN_SRC emacs-lisp
     (setq which-key-enable-extended-define-key t)
   #+END_SRC

   Finally, lets enable =which-key-mode=.
   #+BEGIN_SRC emacs-lisp
     (which-key-mode 1)
   #+END_SRC
** Evil
   [[https://github.com/emacs-evil/evil][evil]] provides us with vim-like keybindings inside of emacs.

   #+BEGIN_SRC emacs-lisp  :results silent
     (use-package evil
       :straight t
       :init
       (setq evil-want-keybinding nil)
       (setq evil-want-C-u-scroll t)
       :config
       (evil-mode 1)
       :after (general)
       :general
       (general-mmap ";" 'evil-ex))
   #+END_SRC

   Next, let's install [[https://github.com/linktohack/evil-commentary][evil-commentary]], which lets us easily comment out code.
   #+BEGIN_SRC emacs-lisp
     (use-package evil-commentary
       :straight t
       :diminish evil-commentary-mode
       :config
       (evil-commentary-mode))
   #+END_SRC

   Let's also install [[https://github.com/emacs-evil/evil-surround][evil-surround]], which lets us wrap a selection.
   #+BEGIN_SRC emacs-lisp
     (use-package evil-surround
       :straight t
       :config
       (global-evil-surround-mode 1))
   #+END_SRC

   Now, when we are in visual-state, we can suround our selection by
   using =S=.

   Finally, let's install [[https://github.com/emacs-evil/evil-collection][evil-collection]].
   #+BEGIN_SRC emacs-lisp
     (use-package evil-collection
       :straight t
       :after evil
       :config
       (setq evil-collection-mode-list nil)
       (evil-collection-init 'xref)
       (evil-collection-init 'info)
       (evil-collection-init 'helpful)
       (evil-collection-init 'dired)
       (evil-collection-init 'flymake)
       (evil-collection-init 'compile)
       (evil-collection-init 'custom)
       (evil-collection-init 'sly)
       (evil-collection-init 'elfeed))
   #+END_SRC

*** Keybinding
    To begin, let's use =general.el= to create a base "definer".
    This starts everything with a =SPC= prefix, and sticks
    it in the =general-override-mode-map= map, which overrides
    other keybindings.
    #+BEGIN_SRC emacs-lisp
      (general-create-definer global-definer
        :keymaps 'override
        :states '(insert emacs normal hybrid motion visual operator)
        :prefix "SPC"
        :non-normal-prefix "C-SPC")
    #+END_SRC

    Because we have mapped =C-u= to scrolling (as in vim), we can't do
    ~universal-argument~. To fix this, let's bind a key to that.
    #+BEGIN_SRC emacs-lisp
      (global-definer
        "u" '(universal-argument :wk "universal"))
    #+END_SRC


    Next, let's create a macro that makes definers for each nested prefix maps.
    This lets us re-use each defininer, and prevent clobbering of definitions.
    #+BEGIN_SRC emacs-lisp
      (defmacro general-global-menu-definer (def infix-key &rest body)
        "Create a definer named general-global-DEF wrapping global-definer.
      The prefix map is named 'my-DEF-map'."
        (let ((definer-name (intern (concat "general-global-" def))))
          (if (fboundp definer-name)
              `(,definer-name ,@body)
            `(progn
               (general-create-definer ,definer-name
                 :wrapping global-definer
                 :prefix-map ',(intern (concat "my-" def "-map"))
                 :infix ,infix-key
                 :wk-full-keys nil
                 "" '(:ignore t :which-key ,def))
               (,definer-name
                 ,@body)))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (general-create-definer general-global-motion-definer
        :keymaps 'override
        :states '(normal motion visual operator)
        :prefix "g")
    #+END_SRC



    Now, let's also make a quick helper for adding mode-specific motions.
    #+BEGIN_SRC emacs-lisp
      (defmacro general-local-motion-definer (mode &rest body)
        `(general-add-hook ,mode
                           (lambda ()
                             (general-define-key
                              :states 'normal
                              :keymaps 'local
                              :prefix "g"
                              ,@body))))
    #+END_SRC

    We also need a mode-specific local leader.
    #+BEGIN_SRC emacs-lisp
      (general-create-definer general-mode-leader-definer
        :states '(normal motion)
        :wrapping global-definer
        :prefix "SPC m"
        "" '(:ignore t :which-key "mode"))
    #+END_SRC
** Ivy
   For our filtering needs, we are going to use ivy.
   To start, let's load up =ivy=.

   By default =ivy= starts every regex with ~^~. I find this annoying,
   so let's just set it to an empty string.

   Also, the default =evil= search is nowhere as good as swiper, so
   let's replace it all together.
   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :straight t
       :diminish ivy-mode
       :init
       (setq ivy-re-builders-alist
             '((counsel-rg . ivy--regex-plus)
               (swiper . ivy--regex-plus)
               (t . ivy--regex-ignore-order)))
       (ivy-mode 1)
       :config
       :general

       (general-mmap "/" 'swiper))
   #+END_SRC

   Next, let's load up =counsel=.
   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :straight t
       :diminish counsel-mode
       :config
       (counsel-mode 1)
       (setq ivy-initial-inputs-alist nil)
       :general
       ("M-x" 'counsel-M-x)
       (global-definer "SPC" '(counsel-M-x :wk "M-x")))
   #+END_SRC

   Finally, let's load =hydra= and friends.
   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :straight t)


     (use-package ivy-hydra
       :straight t
       :after (ivy hydra))
   #+END_SRC
** IMenu
   =imenu= is an extremely handy way of navigating files.
   #+BEGIN_SRC emacs-lisp
     (global-definer
      "i" '(counsel-imenu :wk "imenu"))
   #+END_SRC

** Help
   First, let's replace the default emacs help system with
   [[https://github.com/Wilfred/helpful][helpful]], which provides more information.
   #+BEGIN_SRC emacs-lisp
     (use-package helpful
       :straight t
       :config
       (setq counsel-describe-function-function #'helpful-callable)
       (setq counsel-describe-variable-function #'helpful-variable))
   #+END_SRC

   Next, let's add [[https://github.com/xuchunyang/elisp-demos][elisp-demos]], which provides some nice examples for some
   common functions.
   #+BEGIN_SRC emacs-lisp
     (use-package elisp-demos
       :straight t
       :defer t
       :init
       (advice-add 'helpful-update :after 'elisp-demos-advice-helpful-update))
   #+END_SRC



   First, let's bind some of the =describe= functions
   to keys that are more in line with vim.
   #+BEGIN_SRC emacs-lisp  :results silent
     (general-global-menu-definer "help" "h"
                                  "k" '(describe-key              :wk "describe key")
                                  "F" '(counsel-faces             :wk "describe face")
                                  "f" '(counsel-describe-function :wk "describe function")
                                  "v" '(counsel-describe-variable :wk "describe variable")
                                  "m" '(describe-mode             :wk "describe mode")
                                  "i" '(info                      :wk "info")
                                  "D" '(toggle-debug-on-error     :wk "toggle debugger"))
   #+END_SRC
** Buffers
   Let's bind buffer management to some nicer keys.
   #+BEGIN_SRC emacs-lisp
     (defun open-scratch-buffer ()
       (interactive)
       (display-buffer (get-buffer-create "*scratch*")))

     (general-global-menu-definer "buffer" "b"
                                  "b" '(counsel-switch-buffer :wk "switch buffer")
                                  "d" '(kill-current-buffer   :wk "kill buffer")
                                  "r" '(rename-buffer         :wk "rename buffer"))

     (global-definer
       "," '(counsel-switch-buffer :wk "switch buffer")
       "x" '(open-scratch-buffer   :wk "scratch buffer"))
   #+END_SRC
** Files
   Some handy bindings for opening files.
   #+BEGIN_SRC emacs-lisp
     (defun open-config-file ()
       (interactive)
       (find-file "~/.emacs.d/readme.org"))

     (defun open-private-config-file ()
       (interactive)
       (find-file "~/.emacs.d/private.org"))

     (defun open-straight-repo ()
       (interactive)
       (counsel-find-file "~/.emacs.d/straight/repos/"))

     (general-global-menu-definer "file" "f"
                                  "f" '(counsel-find-file        :wk "find file")
                                  "r" '(counsel-recentf          :wk "recent files")
                                  "s" '(open-straight-repo       :wk "straight repo")
                                  "i" '(open-config-file         :wk "config file")
                                  "I" '(open-private-config-file :wk "private config file"))

     (global-definer
       "." '(counsel-find-file :wk "find file"))
   #+END_SRC
** Windows
   To start, let's install =ace-window=.
   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :straight t
       :config
       (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
       (general-global-menu-definer "window" "w"
                                    "w" '(ace-window :wk "switch") ;; NOTE: You can also use 'SPC u SPC w w'
                                    "W" '((lambda () (interactive) (ace-window 4)) :wk "swap")))
   #+END_SRC



   Let's bind window management to some nicer keys
   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer "window" "w"
                                  "h" '(evil-window-left   :wk "left")
                                  "j" '(evil-window-down   :wk "down")
                                  "k" '(evil-window-up     :wk "up")
                                  "l" '(evil-window-right  :wk "right")
                                  "v" '(evil-window-vsplit :wk "vertical split")
                                  "s" '(evil-window-split  :wk "horizontal split")
                                  "d" '(evil-window-delete :wk "close"))
   #+END_SRC
** Tabs
   Let's use emacs 27 recently added tab support to emulate workspaces.

   First, let's define a nice ivy interface for selecting which tab to switch to.
   #+BEGIN_SRC emacs-lisp
     (defun counsel-switch-tab ()
       "Switch to another tab."
       (interactive)
       (ivy-read "Tab: " (mapcar (lambda (tab) (cdr (assq 'name tab))) (tab-bar-tabs))
                 :action 'tab-bar-switch-to-tab
                 :caller 'counsel-switch-tab))
   #+END_SRC

   Let's also define a nice way to dump and load tab configurations.
   #+BEGIN_SRC emacs-lisp
     (defun save-tab ()
       (let ((saved-tabs (read (get-file-buffer (expand-file-name "tabs" user-emacs-directory))))))
       saved-tabs)
   #+END_SRC

   Don't show the tab bar.
   #+BEGIN_SRC emacs-lisp
     (setq tab-bar-show nil)
   #+END_SRC


   Let's bind some keys!
   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer "tab" "t"
                                  "h" '(tab-previous               :wk "previous")
                                  "l" '(tab-next                   :wk "next")
                                  "n" '(tab-new                    :wk "new")
                                  "d" '(tab-close                  :wk "close")
                                  "r" '(tab-bar-rename-tab         :wk "rename")
                                  "R" '(tab-bar-rename-tab-by-name :wk "rename other tab")
                                  "b" '(switch-to-buffer-other-tab :wk "open buffer in tab")
                                  "f" '(find-file-other-tab        :wk "open file in tab")
                                  "t" '(counsel-switch-tab         :wk "switch tab"))
   #+END_SRC

   Let's also bind some quick extra conveinent bindings.
   #+BEGIN_SRC emacs-lisp
     (general-global-motion-definer
       "t" '(tab-next     :wk "next tab")
       "T" '(tab-previous :wk "previous tab"))
   #+END_SRC
** Toggles
** Misc
*** Spongebob Mode
    #+BEGIN_SRC emacs-lisp
      (define-minor-mode spongebob-mode
        "StAgGeR ThE CaSe iN ThE BuFfeR."
        :lighter " sPoNgEbOb"
        (add-to-list 'after-change-functions #'spongebob-mode--do-it))

      (defun spongebob-mode--do-it (beg end _)
        (when spongebob-mode
          (save-excursion
            (cl-loop for pos from beg below end
                     for char = (char-after pos)
                     for upcase = (upcase char)
                     when (if (cl-oddp pos) (eql char upcase) (not (eql char upcase)))
                     do (progn (setf (point) pos)
                               (delete-char 1)
                               (insert-before-markers upcase))))))
    #+END_SRC
* Org
  I like to have my lines wrapped when writing org files,
  so let's turn on =auto-fill-mode=.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook 'auto-fill-mode)
  #+END_SRC

** Keybindings
   =org-mode= is a monster of a
   mode, with approximately 50 million keybindings.
   As such, this is very much a work in progress!

   First, there are a handful of commands that are useful even when
   not editing an org buffer. Let's bind those to some handy keybindings.

   #+BEGIN_SRC emacs-lisp
     (general-mode-leader-definer 'org-mode-map
       "'" 'org-edit-special)
   #+END_SRC
** Babel
   First, let's ensure that =org-babel= handles indentation nicely.
   #+BEGIN_SRC emacs-lisp
     (setq org-edit-src-content-indentation 2)
     (setq org-src-tab-acts-natively t)
     (setq org-src-preserve-indentation nil)
   #+END_SRC

   It's a bit annoying that =org-babel= asks for confirmation all the time,
   so let's turn it off.
   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC

   Let's also add a hook to prevent =org-babel= from adding tabs.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook (lambda () (setq indent-tabs-mode nil)))
   #+END_SRC

* Auth Source
  =auth-source= lets us store and read GPG encrypted credentials.

  First, let's set our default auth source.
  #+BEGIN_SRC emacs-lisp
    (setq auth-sources '("~/.authinfo.gpg"))
  #+END_SRC

  Next, let's define a quick helper function for loading
  information from =auth-sources=.
  #+BEGIN_SRC emacs-lisp
    (defun fetch-password (&rest params)
      (let ((match (car (apply 'auth-source-search params))))
        (if match
            (let ((secret (plist-get match :secret)))
              (if (functionp secret)
                  (funcall secret)
                secret))
          (error "Password not found for %S" params))))
  #+END_SRC
* Editor
** Projectile
   [[https://github.com/bbatsov/projectile][projectile]] is a project system for emacs, which lets find navigate
   our projects much faster.
   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :straight t)
   #+END_SRC

   To integrate =projectile= into our =ivy= based workflow, we are going to use
   [[https://github.com/ericdanan/counsel-projectile][counsel-projectile]].
   #+BEGIN_SRC emacs-lisp
     (use-package counsel-projectile
       :straight t)
   #+END_SRC

   Finally, let's enable =projectile-mode= globally, and bind the keymap.
   #+BEGIN_SRC emacs-lisp
     (projectile-mode 1)
     (counsel-projectile-mode 1)
   #+END_SRC

   Next, let's bind some keys!
   #+BEGIN_SRC emacs-lisp
     (global-definer
       "p" '(:keymap projectile-command-map :package projectile :wk "project"))
   #+END_SRC
** Autocompletion
   For autocompletion, we are going to use [[https://github.com/company-mode/company-mode][company-mode]].
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :straight t
       :diminish company-mode
       :config
       (setq company-tooltip-align-annotations t
             company-idle-delay 0.3
             company-echo-delay 0))
   #+END_SRC

   For now, let's enable it globally.
   #+BEGIN_SRC emacs-lisp
     (global-company-mode)
   #+END_SRC

   Start autocompletion when you press tab.
   #+BEGIN_SRC emacs-lisp
     (define-key company-mode-map (kbd "TAB") #'company-indent-or-complete-common)
   #+END_SRC
** Snippets
   We use [[https://github.com/joaotavora/yasnippet][yasnippet]] for all of our snippeting needs.
   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :straight t
       :diminish yas-minor-mode)
   #+END_SRC

   The default yas bindings are pretty hard to use, so let's rebind them.
   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer "snippet" "s"
                                  "n" '(yas-new-snippet        :wk "new")
                                  "i" '(yas-insert-snippet     :wk "insert")
                                  "e" '(yas-visit-snippet-file :wk "edit"))
   #+END_SRC

   Lets enable =yasnippet= globally.
   #+BEGIN_SRC emacs-lisp
     (yas-global-mode 1)
   #+END_SRC
** AutoInsert
   Let's use a blend of =auto-insert= and =yassnippet= to handle file templates.
   #+BEGIN_SRC emacs-lisp
     (defun create-file-template (regex template mode)
       (add-to-list 'auto-insert-alist
                    `(,regex .  [(lambda () (yas-expand-snippet (yas-lookup-snippet ,template ',mode)))])))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package autoinsert
       :config
       (setq auto-insert-query nil)            ;; Don't ask the user before inserting
       (auto-insert-mode 1)
       (add-hook 'find-file-hook 'auto-insert) ;; After a file is opened, insert.
       (setq auto-insert-alist nil))
   #+END_SRC
** AutoRevert
   =auto-revert-mode= reverts buffers when the underlying file on disk changes.
   #+BEGIN_SRC emacs-lisp
     (use-package autorevert
       :diminish auto-revert-mode
       :config
       (global-auto-revert-mode))
   #+END_SRC

** Flymake
   We use =flymake= to handle displaying errors inside of buffers.
   However, there a few tweaks required to get things working nicely OOTB.

   For starters, =flymake= doesn't show errors in a posframe, so we need to install
   [[https://github.com/Ladicle/flymake-posframe][flymake-posframe]] for that.
   #+BEGIN_SRC emacs-lisp
     (use-package flymake-posframe
       :straight (flymake-posframe :type git :host github
                                   :repo "Ladicle/flymake-posframe")
       :hook (flymake-mode . flymake-posframe-mode))
   #+END_SRC

   Next, let's add some nice keybindings.
   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer "error" "e")

     (general-global-error
       "j" '(flymake-goto-next-error :wk "next error")
       "k" '(flymake-goto-prev-error :wk "previous error")
       "e" '(flymake-show-diagnostics-buffer :wk "display errors"))
   #+END_SRC

   Now, the =flymake= diagnostic buffer will pop up somewhat randomly, so let's make sure it only
   ever pops up at the bottom.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'display-buffer-alist
                  '("\\*Flymake diagnostics*"
                    (display-buffer-below-selected display-buffer-at-bottom)
                    (inhibit-same-window . t)
                    (window-height . 15)))
   #+END_SRC

** SmartParens
   [[https://github.com/Fuco1/smartparens][smartparens]] provides a bunch of utilities for handling
   pairs in emacs.
   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :straight t
       :diminish smartparens-mode)
   #+END_SRC

   By default, we turn on smartparens globally (but not strict mode).
   The default config is pretty good, so let's bring that in as well.
   #+BEGIN_SRC emacs-lisp
     (require 'smartparens-config)
     (smartparens-global-mode)
   #+END_SRC

   Here are some helpful keybinds.
   #+BEGIN_SRC emacs-lisp
     (evil-define-key 'normal 'global
       "((" 'sp-wrap-round
       "([" 'sp-wrap-square
       "({" 'sp-wrap-curly
       "(u" 'sp-unwrap-sexp)
   #+END_SRC

** Rainbow Parens
   Turn on [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]].
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :straight t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
   #+END_SRC

** Whitespace
   Let's highlight any funky looking whitespace.

   #+BEGIN_SRC emacs-lisp
     (setq whitespace-style '(face trailing empty tabs))
     (global-whitespace-mode)
   #+END_SRC
** XRef
   Let's make the xref buffer a little less intrusive.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'display-buffer-alist
                  '("\\*xref\\*"
                    (display-buffer-below-selected display-buffer-at-bottom)
                    (inhibit-same-window . t)
                    (window-height . 10)))
   #+END_SRC

   Next, let's add some nifty keybindings!
   #+BEGIN_SRC emacs-lisp
     (general-local-motion-definer
      'xref--xref-buffer-mode-hook
      "k" 'xref-prev-line
      "j" 'xref-next-line)
   #+END_SRC

** Undo Tree
   [[https://elpa.gnu.org/packages/undo-tree.html][undo-tree]] lets us visualize Emacs undo history as a tree.
   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :straight t
       :diminish undo-tree-mode
       :config
       (general-global-menu-definer
        "open" "o"
        "u" '(undo-tree-visualize :wk "undo tree")))
   #+END_SRC
* Tools
** Magit
   To start, let's install [[https://github.com/magit/magit][magit]].
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :straight t)
   #+END_SRC

   =magit= is a fantastic tool, but the keybindings don't quite line up with =evil=.
   Let's change that by using [[https://github.com/emacs-evil/evil-magit][evil-magit]].
   #+BEGIN_SRC emacs-lisp
     (use-package evil-magit
       :straight t)
   #+END_SRC

   Now, let's bind some keys!
   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer "git" "g")
     (general-global-git
       "b" '(magit-blame  :wk "blame")
       "g" '(magit-status :wk "status")
       "s" '(magit-status :wk "status"))
   #+END_SRC
** Brew
   It's a pain having to switch to the terminal to use brew,
   so let's use [[https://github.com/TOTBWF/counsel-brew][counsel-brew]] instead.
   #+BEGIN_SRC emacs-lisp
     (use-package counsel-brew
       :if (string= system-type "darwin")
       :straight (counsel-brew :type git :host github
                               :repo "TOTBWF/counsel-brew")
       :commands counsel-brew)
   #+END_SRC
** Docker
   Let's use [[https://github.com/Silex/docker.el][docker.el]] to manage docker containers.
   #+BEGIN_SRC emacs-lisp
     (use-package docker
       :straight t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer
      "docker" "d"
      "c" '(docker-compose :wk "compose"))
   #+END_SRC


   On top of that, let's add some packages for dealing with
   Dockerfiles, and docker-compose files.
   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :straight t)
   #+END_SRC
** GraphiQL
   #+BEGIN_SRC emacs-lisp
     (use-package graphiql
       :straight (graphiql :type git :host github :repo "TOTBWF/graphiql.el")
       :config
       (setq graphiql-use-lsp t)
       (general-local-motion-definer
        'graphiql-mode-hook
        "j" '(graphiql-next-query     :wk "next query")
        "k" '(graphiql-previous-query :wk "previous query")))
   #+END_SRC

** GPG
   Enable prompting for GPG pins.
   #+BEGIN_SRC emacs-lisp
     (setq epa-pinentry-mode 'loopback)
   #+END_SRC

** Comint
   When we are in comint mode, let's bind some quick movement helpers
   #+BEGIN_SRC emacs-lisp
     (general-local-motion-definer
      'comint-mode-hook
      "j" 'comint-next-input
      "k" 'comint-previous-input)
   #+END_SRC

   Let's also bind some keys to make comint history searching less of a pain.
   #+BEGIN_SRC emacs-lisp
   #+END_SRC

** IElm
   Let's give =ielm= a nice shortcut
   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer "open" "o"
                                  "i" '(ielm :wk "ielm"))
   #+END_SRC

** EShell
   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer "open" "o"
                                  "e" '(eshell :wk "eshell"))
   #+END_SRC

   Next, let's create a function that toggles auto scrolling.
   #+BEGIN_SRC emacs-lisp
     (defun eshell-toggle-auto-scroll ()
       (interactive)
       (setq eshell-scroll-to-bottom-on-input (not eshell-scroll-to-bottom-on-input)))
   #+END_SRC

   Now, let's add some helpful motion keys.
   #+BEGIN_SRC emacs-lisp
     (general-local-motion-definer
      'eshell-mode-hook
      "j" 'eshell-next-input
      "k" 'eshell-previous-input)
   #+END_SRC
** Prodigy
   Let's install [[https://github.com/rejeep/prodigy.el][prodigy]] to help us manage long running background processes.

   #+BEGIN_SRC emacs-lisp
     (use-package prodigy
       :straight t
       :init
       (add-to-list 'display-buffer-alist
                    '("\\*prodigy\\*"
                      (display-buffer-below-selected display-buffer-at-bottom)
                      (inhibit-same-window . t)
                      (window-height . 10)))
       :config
       (general-global-menu-definer
        "open" "o"
        "p" '(prodigy :wk "prodigy"))
       (evil-collection-init 'prodigy))
   #+END_SRC
** IRC
   For our irc client we are going to use [[https://github.com/jorgenschaefer/circe][circe]].
   #+BEGIN_SRC emacs-lisp
     (use-package circe
       :straight t)
   #+END_SRC

   I use a IRC bouncer, so leaving the channel when a buffer is killed
   isn't the best behavior for me. To fix this, I redefine =circe-channel-killed=
   to prevent leaving upon buffer close.
   #+BEGIN_SRC emacs-lisp
     (advice-add
      'circe-channel-killed
      :override
      (lambda ()
        (ignore-errors (circe-server-remove-chat-buffer circe-chat-target))))
   #+END_SRC

   Let's also define a quick helper for logging in to irc servers
   using =auth-source=.
   #+BEGIN_SRC emacs-lisp
     (defun fetch-irc-password (server)
       (fetch-password :host server))
   #+END_SRC

   Next, let's add notifications. We will be using [[https://github.com/eqyiel/circe-notifications][circe-notifications]]
   for this.
   #+BEGIN_SRC emacs-lisp
     (use-package circe-notifications
       :straight t
       :after (circe)
       :init
       (add-hook 'circe-server-connected-hook 'enable-circe-notifications)
       :config
       (when (string= system-type "darwin")
         (setq circe-notifications-alert-style 'osx-notifier)))
   #+END_SRC

   I find it rather annoying to switch inbetween channels, so let's
   whip up a quick helper to do just that.
   #+BEGIN_SRC emacs-lisp
     (defun counsel-switch-to-circe-buffer ()
       "Switch to a circe buffer."
       (interactive)
       (ivy-read "IRC Channel: " (counsel--buffers-with-mode #'circe-channel-mode)
                 :action #'ivy--switch-buffer-action
                 :caller 'counsel-switch-to-circe-buffer))

     (defun counsel-switch-to-circe-buffer-transformer (buffer)
       (with-current-buffer buffer
         (let ((server-name (propertize (buffer-name (circe-server-buffer)) 'face 'font-lock-doc-face))
               (read-indicator (when (member buffer tracking-buffers)
                                 (propertize "*" 'face 'error))))
           (concat buffer " " read-indicator "   " server-name))))

     (ivy-set-display-transformer 'counsel-switch-to-circe-buffer 'counsel-switch-to-circe-buffer-transformer)
   #+END_SRC

   Now, let's bring this all together by binding some keys.
   #+BEGIN_SRC emacs-lisp
     (general-global-menu-definer "irc" "y"
      "y" '(counsel-switch-to-circe-buffer :wk "switch to channel")
      "c" '(circe                          :wk "connect"))

     (general-mode-leader-definer 'circe-channel-mode-map
       "j" '(circe-command-JOIN  :wk "join")
       "n" '(circe-command-NAMES :wk "names")
       "r" '(circe-reconnect     :wk "reconnect"))

     (general-mode-leader-definer 'circe-server-mode-map
       "j" '(circe-command-JOIN  :wk "join")
       "r" '(circe-reconnect     :wk "reconnect"))
   #+END_SRC
** RSS
   I use [[https://github.com/skeeto/elfeed][elfeed]] to manage my rss feeds.
   #+BEGIN_SRC emacs-lisp
     (use-package elfeed
       :straight t
       :defer t)
   #+END_SRC

   Now, managing large lists of feeds can be cumbersome, so let's bring
   in [[https://github.com/remyhonig/elfeed-org][elfeed-org]] to help manage that.
   #+BEGIN_SRC emacs-lisp
     (use-package elfeed-org
       :straight t
       :defer t
       :config
       (elfeed-org)
       (setq rmh-elfeed-org-files '("~/org/elfeed.org")))
   #+END_SRC

* LSP
  [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] provides language services for quite a few languages.
  #+BEGIN_SRC emacs-lisp
    (use-package lsp-mode
      :straight t
      :commands lsp
      :init
      (general-local-motion-definer
       'lsp-mode-hook
       "d" 'lsp-find-definition
       "D" 'xref-pop-marker-stack)
      (general-define-key
       :states 'normal
       :keymaps 'lsp-mode-map
       "K" 'lsp-describe-thing-at-point))
  #+END_SRC

  Let's also ensure that the lsp help buffer pops up at the bottom.
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'display-buffer-alist
                 '("\\*lsp-help\\*"
                   (display-buffer-below-selected display-buffer-at-bottom)
                   (inhibit-same-window . t)
                   (window-height . 15)))
  #+END_SRC


  Next, let's add [[https://github.com/tigersoldier/company-lsp][company-lsp]] for autocompletion support.
  #+BEGIN_SRC emacs-lisp
    (use-package company-lsp
      :straight t
      :commands company-lsp)
  #+END_SRC



  Once that's installed, we have to register it as a company backend.
  #+BEGIN_SRC emacs-lisp
    (require 'company-lsp)
    (push 'company-lsp company-backend)
  #+END_SRC

  Next, it's a bit of a pain having to manually set + unset ~lsp-log-io~, so
  let's write a little helper.
  #+BEGIN_SRC emacs-lisp
    (defun lsp-toggle-log-io ()
      "Toggle `lsp-log-io'"
      (interactive)
      (if lsp-log-io
          (setq lsp-log-io nil)
        (setq lsp-log-io t))
      (if lsp-print-performance
          (setq lsp-print-performance t)
        (setq lsp-print-performance nil)))
  #+END_SRC
* Languages
** Agda
   First, we need to load the =agda-input= package.
   This provides an input method for writing agda code.
   #+BEGIN_SRC emacs-lisp
     (use-package agda-input
       :straight (agda-input :type git :host github :repo "agda/agda"
                             :files ("src/data/emacs-mode/agda-input.el")))
   #+END_SRC

   Now, let's load up =agda2-mode= itself.
   #+BEGIN_SRC emacs-lisp
     (use-package agda2-mode
       :straight (agda2-mode :type git :host github
                             :repo "agda/agda"
                             :files ("src/data/emacs-mode/*.el"
                                     (:exclude "agda-input.el")))
       :config
       (add-to-path "~/.local/bin/"))
   #+END_SRC

   Next, lets add a file template for agda files.
   #+BEGIN_SRC emacs-lisp
     (create-file-template ".*.agda$" "cubical-agda-template" 'agda2-mode)
   #+END_SRC
*** Keybindings
    First, let's add the mode keybindings.
    #+BEGIN_SRC emacs-lisp
      (general-mode-leader-definer 'agda2-mode-map
        "l" '(agda2-load   :wk "load")
        "r" '(agda2-refine :wk "refine"))
    #+END_SRC

    Next, let's set up the jump handler.
    #+BEGIN_SRC emacs-lisp
      (general-local-motion-definer
       'agda2-mode-hook
       "j" 'agda2-next-goal
       "k" 'agda2-previous-goal
       "d" 'agda2-goto-definition-keyboard)
    #+END_SRC

*** Theme
    =doom-one= looks pretty horrible with agda code, so let's try to fix that a bit.
    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'agda2-highlight-error-face nil
                          :inherit 'error)
      (set-face-attribute 'agda2-highlight-unsolved-constraint-face nil
                          :inherit 'default
                          :foreground "#e6bdef"
                          :background "#261230")
    #+END_SRC

** C
   For C, we shall be using [[https://github.com/MaskRay/emacs-ccls][ccls]] alongside =lsp-mode=.
   #+BEGIN_SRC emacs-lisp
     (use-package ccls
       :straight t
       :hook ((c-mode c++-mode objc-mode) . 'lsp)
       :config
       (when (string= system-type "darwin")
         (setq ccls-initialization-options
               `(:clang (:resourceDir "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.1"
                         :extra-args ["-isystem" "/Library/Developer/CommandLineTools/usr/include/c++/v1"
                                      "-isystem" "/Library/Developer/CommandLineTools/usr/lib/clang/10.0.1/include"
                                      "-isystem" "/Library/Developer/CommandLineTools/usr/include"
                                      "-isystem" "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include"])))))
   #+END_SRC

   Let's make sure to not look inside the =ccls= cache when doing
   projectile searches.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'projectile-globally-ignored-directories ".ccls-cache")
   #+END_SRC

   For some insane reason, MakeFiles require tabs.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'makefile-mode-hook (lambda ()
                                     (setq indent-tabs-mode t)))
   #+END_SRC

** CSS
   #+BEGIN_SRC emacs-lisp
     (add-hook 'less-css-mode-hook #'lsp)
     (add-hook 'css-mode-hook #'lsp)
     (setq css-indent-offset 2)
   #+END_SRC
** F#
   We use [[https://github.com/fsharp/emacs-fsharp-mode][fsharp-mode]] to provide font locking and indentation for F#.
   #+BEGIN_SRC emacs-lisp
     (use-package fsharp-mode
       :straight t
       :config
       (add-hook 'fsharp-mode-hook 'lsp)
       :custom
       (fsharp-ac-intellisense-enabled nil))
   #+END_SRC

   Next, let's load up the F# language server from =lsp-mode=
   #+BEGIN_SRC emacs-lisp
     (require 'lsp-fsharp)
   #+END_SRC

   Finally, let's make sure that the =dotnet= executable is available on our path.
   #+BEGIN_SRC emacs-lisp
     (add-to-path "/usr/local/share/dotnet/")
   #+END_SRC
** Haskell
   First, let's install =haskell-mode=. This provides syntax
   highlighting and repl interaction.


   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :straight t
       :config
       (setq haskell-interactive-popup-errors nil))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package dante
       :straight t
       :after haskell-mode
       :hook (haskell-mode . dante-mode)
       :init
       (add-hook 'haskell-mode-hook 'flymake-mode)
       :config
       (setq dante-methods '(new-build stack bare-cabal bare-ghci))
       ;; Dante only checks saved buffers, so let's disable on the fly checking
       (setq-local flymake-no-changes-timeout nil)
       (setq-local flymake-start-syntax-check-on-newline nil))
   #+END_SRC

   Next, let's define some keybindings.
   #+BEGIN_SRC emacs-lisp

   #+END_SRC

** Lisp
   Next, let's enable [[https://github.com/abo-abo/lispy][lispy]] for editing lisp code.
   #+BEGIN_SRC emacs-lisp
     (use-package lispy
       :straight t
       :hook (emacs-lisp-mode . lispy-mode)
       :config
       (setq lispy-colon-p nil))
   #+END_SRC

   Let's also add [[https://github.com/noctuid/lispyville][lispyville]] for better evil integration.
   #+BEGIN_SRC emacs-lisp
     (use-package lispyville
       :straight t
       :after lispy
       :hook (lispy-mode . lispyville-mode)
       :config
       (lispyville-set-key-theme '(operators)))
   #+END_SRC
*** Emacs Lisp
    Let's enable =flymake-mode= when editing elisp code.
    #+BEGIN_SRC emacs-lisp
      (general-add-hook 'emacs-lisp-mode-hook
                        '(flymake-mode))
    #+END_SRC

    Let's also install [[https://github.com/Fanael/highlight-defined][highlight-defined]], which will handily highlight defined
    emacs lisp symbols.
    #+BEGIN_SRC emacs-lisp
      (use-package highlight-defined
        :straight t
        :hook (emacs-lisp-mode . highlight-defined-mode))
    #+END_SRC
*** Scheme
    For scheme, we are going to use [[http://www.nongnu.org/geiser/][geiser]].
    #+BEGIN_SRC emacs-lisp
      (use-package geiser
        :straight t
        :gfhook
        'lispy-mode
        :config
        (setq geiser-chez-binary "chez"))
    #+END_SRC
*** Common Lisp
    Let's try out =sly=.
    #+BEGIN_SRC emacs-lisp
      (use-package sly
        :straight t
        :config
        (setq inferior-lisp-program "/usr/bin/sbcl")
        :gfhook 'lispy-mode)
    #+END_SRC

** Typescript
   Typescript is a bit of a pain to get working, mostly due to
   the evils of JSX.

   We are going to need to install [[http://web-mode.org/][web-mode]] for =tsx= support.
   Emacs 27 did add =jsx= support, but the indentation behaves rather oddly
   when dealing with type annotations.
   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :straight t
       :custom
       (web-mode-code-indent-offset 2 "Set indentation of js code to 2")
       (web-mode-markup-indent-offset 2 "Set indentation of js code to 2")
       (web-mode-indentation-params '(("lineup-args" . t)
                                      ("lineup-calls" . t)
                                      ("lineup-concats" . t)
                                      ("lineup-quotes" . t)
                                      ("lineup-ternary" . nil)
                                      ("case-extra-offset" . t)))
       (web-mode-enable-auto-quoting nil))
   #+END_SRC

   Next, let's make sure that we don't look inside of =node_modules=
   when using projectile file search.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'projectile-globally-ignored-directories "node_modules")
   #+END_SRC


   Next, let's load the typescript language server.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.ts[x]?\\'" . web-mode))
     (add-hook 'web-mode-hook
               (lambda ()
                 (when (or (string= web-mode-content-type "jsx")
                           (string= web-mode-content-type "javascript"))
                   (lsp))))
   #+END_SRC

   While we are at it, let's enable =flymake-eslint=.
   #+BEGIN_SRC emacs-lisp
     (use-package flymake-eslint
       :straight t
       :init
       (add-hook 'web-mode-hook (lambda () (flymake-eslint-enable))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp

   #+END_SRC


   Next, let's add =npm-mode=.
   #+BEGIN_SRC emacs-lisp
     (use-package npm-mode
       :straight t)
   #+END_SRC

** Purescript
   First, let's use =purescript-mode= for syntax highlighting + indentation.
   #+BEGIN_SRC emacs-lisp
     (use-package purescript-mode
       :straight t
       :config
       (add-hook 'purescript-mode-hook
                 (lambda ()
                   (psc-ide-mode)
                   (flycheck-mode)
                   (turn-on-purescript-indentation))))
    #+END_SRC

    We also use =psc-ide= to handle autocompletion + errors.
    #+BEGIN_SRC emacs-lisp
      (use-package psc-ide
        :straight t)
    #+END_SRC

    Let's also set some jump handlers.
    #+BEGIN_SRC emacs-lisp
      (general-local-motion-definer
       'purescript-mode-hook
       "d" 'psc-ide-goto-definition)
    #+END_SRC

* Private Configuration
  If you want to have personal configurations
  (irc servers, etc), you can create a file called
  =private.org= and place them there. Let's load
  and tangle the file (if it exists).
  #+BEGIN_SRC emacs-lisp
    (when (file-exists-p "~/.emacs.d/private.el")
      (load "~/.emacs.d/private.el"))
  #+END_SRC
  When saving customizations, let's use another file.
  #+BEGIN_SRC emacs-lisp
    (setq custom-file "~/.emacs.d/custom.el")
    (when (file-exists-p "~/.emacs.d/custom.el")
      (load "~/.emacs.d/custom.el"))
  #+END_SRC
